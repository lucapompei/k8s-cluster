pipeline {

  // Incoming data
  parameters {

    // Base data
    string(name: 'projectName', description: 'The project name')
    string(name: 'gitUrl', description: 'The project git url')
    string(name: 'gitBranch', description: 'The project git branch to use to run CI/CD')
    string(name: 'gitTag', defaultValue: '', description: 'The project git tag to use to run CI/CD')
    string(name: 'gitTestBranch', defaultValue: 'develop', description: 'The git branch to use to know if push on test environment')
    string(name: 'gitCollBranch', defaultValue: 'release', description: 'The git branch to use to know if push on coll environment')
    string(name: 'gitProdBranch', defaultValue: 'master', description: 'The git branch to use to know if push on prod environment')
    
    // Build data
    string(name: 'jdkVersion', defaultValue: 'OpenJDK-11', description: 'The JDK to use to build the project')
    string(name: 'customMavenProfile', defaultValue: '', description: 'A custom maven profile to use for building phase')

    // Kubernetes data
    booleanParam(name: 'toKubernetes', defaultValue: false, description: 'Indicates whether the deployment is directed to Kubernetes')
    string(name: 'kubernetesCredentials', description: 'The Kubernetes credentials ID stored in Jenkins')
    string(name: 'kubernetesCluster', description: 'The Kubernetes cluster name in which to deploy')

    // Mattermost data
    booleanParam(name: 'toMattermost', defaultValue: false, description: 'Indicates whether the deployment is directed to Kubernetes')
    string(name: 'mattermostChannel', description: 'The Mattermost channel ID in which to send the notification')
    string(name: 'mattermostUrlWebHook', description: 'The Mattermost webhook to use to send the notification')

    // Second remote data
    booleanParam(name: 'toRemoteGit', defaultValue: false, description: 'Indicates whether the deployment is directed to a remote git')
    string(name: 'gitRemoteTestBranch', defaultValue: 'develop', description: 'The remote git branch to use to push on remote test environment')
    string(name: 'gitRemoteCollBranch', defaultValue: 'release', description: 'The remote git branch to use to push on remote coll environment')
    string(name: 'gitRemoteProdBranch', defaultValue: 'master', description: 'The remote git branch to use to push on remote prod environment')
    string(name: 'gitRemoteCredentials', description: 'The git credentials to use to push on remote')
    string(name: 'gitRemoteUrl', description: 'The git url to use to push on remote')
    string(name: 'gitRemoteConfigEmail', description: 'The git email to use to push on remote')
    string(name: 'gitRemoteConfigName', description: 'The git name to use to push on remote')

  }

  environment {

    // Gitlab properties
    gitlabCredentialsId = 'gitlab-sysdata'

    // SonarQube properties
    sonarServer = 'Sonar'

    // Docker properties
    registryURL = '******'
    registryCredential = '******'

  }

  agent any
  
  tools {
    jdk params.jdkVersion
    maven 'maven-3.8'
  }

  stages {

    stage('Getting environment') {
      steps {
        script {
          env.NORMALIZED_GIT_BRANCH = gitBranch.replace('origin/', '');
          echo "Running CI/CD with the following environment"
          echo "ProjectName: ${projectName}"
          echo "GitUrl: ${gitUrl}"
          echo "GitBranch: ${env.NORMALIZED_GIT_BRANCH}"
          echo "GitTag: ${gitTag}"
          echo "Custom maven profile for build: ${customMavenProfile}"
          echo "Deploy to Kubernetes: ${toKubernetes}"
          echo "Post to Mattermost: ${toMattermost}"
          echo "Push to remote git: ${toRemoteGit}"
          git branch: env.NORMALIZED_GIT_BRANCH, credentialsId: gitlabCredentialsId, url: gitUrl
        }
      }
    }

    stage('Compiling application') {
      steps {
        script {
          echo "Compiling application"
          sh "mvn -DskipTests clean package ${customMavenProfile}"
        }
      }
    }
    
    stage('Test') {
      steps {
        echo 'Executing tests and creating reports for Jacoco'
        sh 'mvn surefire-report:report'
      }
      
      post {
        always {
          // Make reports available for Jacoco
          junit 'target/surefire-reports/*.xml'
        }
      }
    }

    stage('SonarQube analysis') {
	    steps {
	      script {
          // Other environments are dev sub-set, there is no need to perform another scan
	        if (env.NORMALIZED_GIT_BRANCH.contains(gitTestBranch)) {
	          try {
              // It requires SonarQube Scanner 2.8+
              def scannerHome = tool 'SonarQube Scanner';
              withSonarQubeEnv(sonarServer) {
                sh "${scannerHome}/bin/sonar-scanner"
              }
            } catch (Exception e) {
              echo "Error during reporting on SonarQube"
            }
          } else {
	          echo "Skipping SonarQube in a non-dev environment"
	        }
	   	  }
	    }
	  }
	
	  stage("Quality Gate") {
      steps {
        script {
          // Other environments are dev sub-set, there is no need to perform another scan
          if (env.NORMALIZED_GIT_BRANCH.contains(gitTestBranch)) {
            timeout(time: 1, unit: 'HOURS') {
              // Waiting for quality gate response before going on
              waitForQualityGate abortPipeline: true
            }
          } else {
            echo "Skipping Quality Gate check in a non-dev environment"
          }
        }
      }
    }

    stage('Building Docker image') {
      steps {
        script {
          if (toKubernetes.toString() == "true") {
            echo "Building Docker image"
            docker.withRegistry(registryURL + projectName, registryCredential) {
              def baseImage = docker.build(projectName + ":latest");
              baseImage.push()
              docker.build(projectName + ":${env.BUILD_NUMBER}").push()
              if (gitTag != null && gitTag != "") {
                docker.build(projectName + ":${gitTag}").push()
              }
              echo "Docker image pushed"
            }
          } else {
            echo "Kubernetes deploy is disabled, skipping phase"
          }
        }
      }
    }

    stage('Publishing on Kubernetes') {
      steps {
        script {
          if (toKubernetes.toString() == "true") {
            // TODO: to handle other environments
            if (!gitBranch.contains(gitProdBranch)) {
              echo "Not master branch, skipping deploy on Kubernetes"
            } else {
              echo "Publishing on Kubernetes"
              sh "config/interpolate.sh"
              withCredentials([kubeconfigContent(credentialsId: kubernetesCredentials, variable: 'KUBECONFIG_CONTENT')]){
                sh '''echo "$KUBECONFIG_CONTENT" > kubeconfig'''
                // Update Kubernetes configuration
                sh("kubectl --kubeconfig=kubeconfig -f config/deployment.yml")
              }
            }
          } else {
            echo "Kubernetes deploy is disabled, skipping phase"
          }
        }
      }
    }

    stage('Publishing on remote Git') {
      steps {
        script {
          if (toRemoteGit.toString() == "true") {
            def branchToPush;
            if (env.NORMALIZED_GIT_BRANCH.contains(gitTestBranch)) {
              branchToPush = env.NORMALIZED_GIT_BRANCH.replace(gitTestBranch, gitRemoteTestBranch)
            } else if (env.NORMALIZED_GIT_BRANCH.contains(gitCollBranch)) {
              branchToPush = env.NORMALIZED_GIT_BRANCH.replace(gitCollBranch, gitRemoteCollBranch)
            } else if (env.NORMALIZED_GIT_BRANCH.contains(gitProdBranch)) {
              branchToPush = env.NORMALIZED_GIT_BRANCH.replace(gitProdBranch, gitRemoteProdBranch)
            }
            if (branchToPush != null) {
              echo "Pushing on remote Git to ${branchToPush}"
              withCredentials([usernamePassword(credentialsId: gitRemoteCredentials, passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                sh "git config user.email ${gitRemoteConfigEmail}"
                sh "git config user.name ${gitRemoteConfigName}"
                sh "git checkout ${env.NORMALIZED_GIT_BRANCH}"
                sh "git -c http.sslVerify=false push https://${GIT_USERNAME}:${GIT_PASSWORD}@${gitRemoteUrl} ${env.NORMALIZED_GIT_BRANCH}:${branchToPush}"
              }
            } else {
              echo "Skipping push to remote Git due to a not recognized branch: ${env.NORMALIZED_GIT_BRANCH}"
            }
          } else {
            echo "Push to remote Git is disabled, skipping phase"
          }
        }
      }
    }

  }
    
  post {
    always {
      echo 'One way or another, I have finished'
      deleteDir() /* clean up our workspace */
    }

    success {
      sendToMattermost("#a4c639", "Build n.${env.BUILD_NUMBER} of ${env.JOB_NAME} completed")
    }

    unstable {
      sendToMattermost("#ffbf00", "Build Unstable!")
    }

    failure {
      sendToMattermost("#c0392b", "WARNING -- Build FAILURE!!")
    }

    changed {
      sendToMattermost("#ffbf00", "Things were different before...")
    }
  }

}

@NonCPS
def sendToMattermost(String color, String message) {
  if (toMattermost.toString() == "true") {
    mattermostSend(color: color, icon: "https://jenkins.io/images/logos/jenkins/jenkins.png", message: message, channel: $mattermostChannel, endpoint: $mattermostUrlWebHook)
  } else {
    echo "Mattermost notification is disabled, skipping communication"
  }
}